// Generated by CoffeeScript 1.11.1

/*
 *
 * Global Style objects, including materials for roads, lines, etc.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 */

(function() {
  SEE.init_style = function() {
    SEE.style = {
      renderer_clear_color: 0x000000,
      discretization_length: 10,
      pipe_radius: 10,
      m_default_fill: new THREE.MeshLambertMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide
      }),
      m_flat_fill: new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide
      }),
      m_default_line: new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 5
      }),
      m_transparent: new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: .1
      }),
      m_translucent: new THREE.MeshLambertMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: .5
      }),
      highlight: new THREE.Color(0x0000ff),
      error: new THREE.Color(0xff0000),
      action: new THREE.Color(0x72E261),
      c_normal: new THREE.Color(0xdddddd)
    };
    SEE.params = {
      preview_material: SEE.style.m_default_fill
    };
    SEE.style.loader = new THREE.TextureLoader();
    SEE.style.newSprite = function(url, dim) {
      var container, geom, mat, mesh, texture;
      texture = SEE.style.loader.load(url);
      geom = new THREE.PlaneBufferGeometry(dim.w, dim.h, 32);
      mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
        map: texture,
        transparent: true
      });
      mesh = new THREE.Mesh(geom, mat);
      mesh.position.x = dim.w / 2;
      mesh.position.y = dim.h / 2;
      mesh.rotation.z = Math.PI;
      mesh.scale.x = -1;
      container = new THREE.Object3D();
      container.add(mesh);
      container.position.x = dim.x;
      container.position.y = dim.y;
      return container;
    };
    SEE.style.fontLoader = new THREE.FontLoader();
    SEE.style.textMeshQueue = [];

    /*
    SEE.style.fontLoader.load('fonts/Raleway_Regular.typeface.json',
                               (font) ->
    
                                    SEE.style.font = font
    
                                    for params in SEE.style.textMeshQueue
                                        SEE.style.newText(params)
                               )
     */
    SEE.style.newText = function(params) {
      var geometry, message, shapes;
      if (!SEE.style.font) {
        SEE.style.textMeshQueue.push(params);
        return;
      }
      if (params.fill_color || params.outline_color) {
        message = params.message;
        shapes = SEE.style.font.generateShapes(message, params.height, 2);
        geometry = new THREE.ShapeGeometry(shapes);
        geometry.computeBoundingBox();
      }
      if (params.fill_color) {
        SEE.style.newFillText(params, shapes, geometry);
      }
      if (params.outline_color) {
        return SEE.style.newOutlineText(params, shapes, geometry);
      }
    };
    SEE.style.newFillText = function(params, shapes, geometry) {
      var color_fill, material_fill, output, text, textShape, tx, xMid;
      output = params.out;
      textShape = new THREE.BufferGeometry();
      color_fill = params.fill_color;
      material_fill = new THREE.LineBasicMaterial({
        color: color_fill,
        side: THREE.DoubleSide
      });
      xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      geometry.scale(1, -1, 1);
      tx = 0;
      if (params.align_center) {
        tx = xMid;
      }
      geometry.translate(tx, params.height, 0);
      textShape.fromGeometry(geometry);
      text = new THREE.Mesh(textShape, material_fill);
      return output.add(text);
    };
    return SEE.style.newOutlineText = function(params, shapes, geometry) {
      var color_outline, hole, holeShapes, i, j, k, l, lineGeometry, lineMesh, lineText, m, material_outline, output, ref, ref1, ref2, shape, tx;
      output = params.out;
      color_outline = params.outline_color;
      material_outline = new THREE.MeshBasicMaterial({
        color: color_outline,

        /*
        transparent: true,
        opacity: 1.0,
        FIXME: Specify Opacity settings.
         */
        side: THREE.DoubleSide
      });
      holeShapes = [];
      for (i = k = 0, ref = shapes.length; k < ref; i = k += 1) {
        shape = shapes[i];
        if (shape.holes && shape.holes.length > 0) {
          for (j = l = 0, ref1 = shape.holes.length; l < ref1; j = l += 1) {
            hole = shape.holes[j];
            holeShapes.push(hole);
          }
        }
      }
      shapes.push.apply(shapes, holeShapes);
      lineText = new THREE.Object3D();
      tx = 0;
      if (params.align_center) {
        tx = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      }
      for (i = m = 0, ref2 = shapes.length; m < ref2; i = m += 1) {
        shape = shapes[i];
        lineGeometry = shape.createPointsGeometry();
        lineGeometry.scale(1, -1, 1);
        lineGeometry.translate(tx, params.height, 0);
        lineMesh = new THREE.Line(lineGeometry, material_outline);
        lineText.add(lineMesh);
      }
      output.add(lineText);
    };
  };

  SEE.init_style();

}).call(this);
