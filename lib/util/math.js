// Generated by CoffeeScript 1.11.1
(function() {
  SEE.Math = {};

  SEE.Math.distance = function(x1, y1, x2, y2, z1, z2) {
    return Math.sqrt(SEE.Math.distance_sqr(x1, y1, x2, y2, z1, z2));
  };

  SEE.Math.distance_sqr = function(x1, y1, x2, y2, z1, z2) {
    var dx, dy, dz;
    if (z1 === void 0) {
      dz = 0;
    } else {
      dz = z1 - z2;
    }
    dx = x1 - x2;
    dy = y1 - y2;
    return dx * dx + dy * dy + dz * dz;
  };

  SEE.Math.GeometryToTriangles = function(geometry, vertexTransform, out_indices) {
    var a, b, c, face, faces, i, index_a, index_b, index_c, j, k, l, len, len1, output, ref, ref1, triangle, v1, v2, v3, vert_a, vert_b, vert_c, verts;
    if (vertexTransform === void 0) {
      vertexTransform = new Matrix3();
    }
    if (geometry instanceof THREE.Geometry) {
      console.log(geometry);
      faces = geometry.faces;
      verts = geometry.vertices;
      output = [];
      for (j = 0, len1 = faces.length; j < len1; j++) {
        face = faces[j];
        index_a = face.a;
        index_b = face.b;
        index_c = face.c;
        vert_a = verts[index_a].clone().applyMatrix4(vertexTransform);
        vert_b = verts[index_b].clone().applyMatrix4(vertexTransform);
        vert_c = verts[index_c].clone().applyMatrix4(vertexTransform);
        triangle = new THREE.Triangle(vert_a, vert_b, vert_c);
        output.push(triangle);
        if (out_indices) {
          out_indices.push(index_a);
          out_indices.push(index_b);
          out_indices.push(index_c);
        }
      }
      return output;
    }
    if (geometry instanceof THREE.BufferGeometry) {
      verts = geometry.getAttribute('position');
      faces = geometry.getAttribute('index');
      if (!faces) {
        len = verts.count;
        faces = [];
        for (i = k = 0, ref = len; k < ref; i = k += 3) {
          faces.push(i);
          faces.push(i + 1);
          faces.push(i + 2);
        }
      } else {
        faces = faces.array;
      }
      output = [];
      len = faces.length;
      for (i = l = 0, ref1 = len; l < ref1; i = l += 3) {
        a = faces[i];
        b = faces[i + 1];
        c = faces[i + 2];
        v1 = new THREE.Vector3(verts.getX(a), verts.getY(a), verts.getZ(a));
        v2 = new THREE.Vector3(verts.getX(b), verts.getY(b), verts.getZ(b));
        v3 = new THREE.Vector3(verts.getX(c), verts.getY(c), verts.getZ(c));
        v1.applyMatrix4(vertexTransform);
        v2.applyMatrix4(vertexTransform);
        v3.applyMatrix4(vertexTransform);
        triangle = new THREE.Triangle(v1, v2, v3);
        output.push(triangle);
        if (out_indices) {
          out_indices.push(a);
          out_indices.push(b);
          out_indices.push(c);
        }
      }
      return output;
    }
    debugger;
    console.error("ERROR: SEE.Math.GeometryToTriangles, Geometry Input Type not supported:" + geometry);
  };

}).call(this);
