// Generated by CoffeeScript 1.11.1

/*

Written on Sept.30.2017 by Bryce Summers
Purpose: Generates a set of impressions from models and a camera.

These impression are used to genreate a 3D image.

An Impression Field discretizes and quantizes an image signal into a way of seeing the abstract.
 */

(function() {
  SEE.Impression = (function() {
    function Impression(x1, y1, default_val) {
      this.x = x1;
      this.y = y1;
      this.pos = new BDS.Point(this.x, this.y);
    }

    Impression.prototype.hasPt = function() {
      return this.pt_right !== null || this.pt_down !== null;
    };

    Impression.prototype.clear = function() {
      this.val_front = null;
      this.val_back = null;
      this.pt_right = null;
      this.pt_down = null;
      this.marked = false;
      this.nx = null;
      this.ny = null;
      return this.nz = null;
    };

    return Impression;

  })();

  SEE.E_Impressions = (function() {
    function E_Impressions(xNum, yNum, default_val, width, height) {
      this.visual_set = new Set(['outline', 'nx', 'ny', 'nz']);
      this.partitions = 2;
      this.depth_scale = 5;
      this.unit_meshes = new SEE.Unit_Meshes();
      this.default_val = default_val;
      this.xNum = xNum;
      this.yNum = yNum;
      this.impressions = [];
      this.col_w = width / xNum;
      this.row_h = height / yNum;
      this.width = width;
      this.height = height;
      this._discretize(xNum, yNum, this.col_w, this.row_h, default_val);
    }

    E_Impressions.prototype._discretize = function(xNum, yNum, col_w, row_h, default_val) {
      var col, j, ref, results, row, x, y;
      results = [];
      for (row = j = 0, ref = yNum; j < ref; row = j += 1) {
        results.push((function() {
          var k, ref1, results1;
          results1 = [];
          for (col = k = 0, ref1 = xNum; k < ref1; col = k += 1) {
            x = col_w * col + Math.random() * col_w;
            y = row_h * row + Math.random() * row_h;
            results1.push(this.impressions.push(new SEE.Impression(x, y, 0, default_val)));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    E_Impressions.prototype.getImpression = function(mouse_x, mouse_y) {
      var column, pos, ref, row;
      pos = new BDS.Point(mouse_x, mouse_y);
      ref = this._getRowColumn(pos), row = ref[0], column = ref[1];
      return this._getImpression(row, column);
    };

    E_Impressions.prototype._getImpression = function(row, col) {
      var index;
      index = this._getIndex(row, col);
      return this.impressions[index];
    };

    E_Impressions.prototype._getIndex = function(row, col) {
      if (row >= this.yNum) {
        row = this.yNum - 1;
      }
      if (col >= this.xNum) {
        col = this.xNum - 1;
      }
      if (row < 0) {
        row = 0;
      }
      if (col < 0) {
        col = 0;
      }
      return row * this.xNum + col;
    };

    E_Impressions.prototype._getRowColumn = function(pos) {
      var col, row, x, y;
      x = pos.x;
      y = pos.y;
      row = Math.floor(y / this.row_h);
      col = Math.floor(x / this.col_w);
      return [row, col];
    };

    E_Impressions.prototype.quantize = function(geometry, transform, camera) {
      var i, i1, i2, i3, index, j, k, l, len, m, neighbors, out_indices, ref, ref1, ref2, results, triangle, triangle_list, vertex_normal, vertex_normals;
      out_indices = [];
      geometry = new THREE.Geometry().fromBufferGeometry(geometry);
      geometry.mergeVertices();
      triangle_list = SEE.Math.GeometryToTriangles(geometry, transform, out_indices);
      for (index = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        triangle_list[index] = BDS.Triangle.from_abc_triangle(triangle_list[index]);
      }
      neighbors = {};
      for (index = k = 0, ref1 = triangle_list.length; k < ref1; index = k += 1) {
        triangle = triangle_list[index];
        i1 = out_indices[index * 3];
        i2 = out_indices[index * 3 + 1];
        i3 = out_indices[index * 3 + 2];
        triangle.setIndices(i1, i2, i3);
        this.addNeighbor(neighbors, i1, triangle);
        this.addNeighbor(neighbors, i2, triangle);
        this.addNeighbor(neighbors, i3, triangle);
      }
      vertex_normals = [];
      for (i = l = 0, ref2 = geometry.vertices.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        vertex_normal = this.computeVertexNormal(i, neighbors);
        vertex_normals.push(vertex_normal);
      }
      results = [];
      for (m = 0, len = triangle_list.length; m < len; m++) {
        triangle = triangle_list[m];
        results.push(this._quantizeTriangle(triangle, camera, vertex_normals));
      }
      return results;
    };

    E_Impressions.prototype.computeVertexNormal = function(index, neighbors) {
      var a, average, count, iter, normal, original_index, triangle, triangles, v;
      original_index = index;
      triangles = neighbors[index];
      count = 0;
      average = new THREE.Vector3(0, 0, 0);
      iter = triangles.values();
      while ((v = iter.next(), !v.done)) {
        triangle = v.value;
        normal = triangle.normal();
        a = triangle.a;
        if (a.dot(normal) < 0) {
          normal.multScalar(-1);
        }
        average.add(normal);
        count += 1;
      }
      average.divideScalar(count);
      average.normalize();
      return average;
    };

    E_Impressions.prototype.addNeighbor = function(neighbors, key, val) {
      var list;
      list = neighbors[key];
      if (list === void 0) {
        list = new Set();
        neighbors[key] = list;
      }
      return list.add(val);
    };

    E_Impressions.prototype._quantizeTriangle = function(triangle, camera, vertex_normals) {
      var a_h, a_w, b_h, b_w, bbox, c_h, c_w, i1, i2, i3, imp, imp_set, j, len, n_h, n_w, na_h, na_w, nb_h, nb_w, nc_h, nc_w, normal, per1, per2, per3, ref, screen_a, screen_b, screen_c, screen_polygon, toCamera, toProjection, v, val, z_interp;
      toCamera = camera.matrixWorldInverse;
      toProjection = camera.projectionMatrix;
      v = triangle.a;
      a_w = v;
      a_h = new THREE.Vector4(v.x, v.y, v.z, 1);
      v = triangle.b;
      b_w = v;
      b_h = new THREE.Vector4(v.x, v.y, v.z, 1);
      v = triangle.c;
      c_w = v;
      c_h = new THREE.Vector4(v.x, v.y, v.z, 1);
      v = triangle.normal();
      n_w = v;
      n_h = new THREE.Vector4(v.x, v.y, v.z, 0);
      i1 = triangle.a_index;
      i2 = triangle.b_index;
      i3 = triangle.c_index;
      v = vertex_normals[i1];
      na_w = v;
      na_h = new THREE.Vector4(v.x, v.y, v.z, 0);
      v = vertex_normals[i2];
      nb_w = v;
      nb_h = new THREE.Vector4(v.x, v.y, v.z, 0);
      v = vertex_normals[i3];
      nc_w = v;
      nc_h = new THREE.Vector4(v.x, v.y, v.z, 0);
      a_h.applyMatrix4(toCamera);
      a_h.applyMatrix4(toProjection);
      b_h.applyMatrix4(toCamera);
      b_h.applyMatrix4(toProjection);
      c_h.applyMatrix4(toCamera);
      c_h.applyMatrix4(toProjection);
      n_h.applyMatrix4(toCamera);
      n_h.applyMatrix4(toProjection);
      na_h.applyMatrix4(toCamera);
      na_h.applyMatrix4(toProjection);
      nb_h.applyMatrix4(toCamera);
      nb_h.applyMatrix4(toProjection);
      nc_h.applyMatrix4(toCamera);
      nc_h.applyMatrix4(toProjection);
      screen_a = this.projection_to_screen(a_h);
      screen_b = this.projection_to_screen(b_h);
      screen_c = this.projection_to_screen(c_h);
      bbox = new BDS.Box();
      bbox.expandByPoint(screen_a);
      bbox.expandByPoint(screen_b);
      bbox.expandByPoint(screen_c);
      imp_set = this.lookupImpressionsInBox(bbox);
      screen_polygon = new BDS.Polyline(true, [screen_a, screen_b, screen_c], true);
      a_h.divideScalar(a_h.w);
      b_h.divideScalar(b_h.w);
      c_h.divideScalar(c_h.w);
      for (j = 0, len = imp_set.length; j < len; j++) {
        imp = imp_set[j];
        if (n_h.z < 0 && screen_polygon.containsPoint(imp.pos)) {
          ref = this.baryPercentages(screen_a, screen_b, screen_c, imp.pos), per1 = ref[0], per2 = ref[1], per3 = ref[2];
          val = z_interp = a_h.z * per1 + b_h.z * per2 + c_h.z * per3;
          if (n_h.z < 0) {
            imp.val_front = val;
          } else {
            imp.val_back = val;
          }
          normal = na_h.clone().multiplyScalar(per1).add(nb_h.multiplyScalar(per2)).add(nc_h.multiplyScalar(per3));
          normal.normalize();
          imp.nx = normal.x;
          imp.ny = normal.y;
          imp.nz = normal.z;
        }
      }
    };

    E_Impressions.prototype.baryPercentages = function(screen_a, screen_b, screen_c, pt) {
      var len1, len2, len3, per1, per2, per3, total_len;
      len1 = screen_a.distanceTo(pt);
      len2 = screen_b.distanceTo(pt);
      len3 = screen_c.distanceTo(pt);
      total_len = len1 + len2 + len3;
      per1 = len1 / total_len;
      per2 = len2 / total_len;
      per3 = len3 / total_len;
      return [per1, per2, per3];
    };

    E_Impressions.prototype.lookupImpressionsInBox = function(box) {
      var col, impression, j, k, max, max_column, max_row, min, min_column, min_row, outputs, ref, ref1, ref2, ref3, ref4, ref5, row;
      outputs = [];
      min = box.min;
      max = box.max;
      ref = this._getRowColumn(min), min_row = ref[0], min_column = ref[1];
      ref1 = this._getRowColumn(max), max_row = ref1[0], max_column = ref1[1];
      for (row = j = ref2 = min_row, ref3 = max_row; j <= ref3; row = j += 1) {
        for (col = k = ref4 = min_column, ref5 = max_column; k <= ref5; col = k += 1) {
          impression = this._getImpression(row, col);
          outputs.push(impression);
        }
      }
      return outputs;
    };

    E_Impressions.prototype.projection_to_screen = function(v) {
      var x, y;
      x = (v.x + 1) * this.width / 2;
      y = (v.y + 1) * this.height / 2;
      return new BDS.Point(x, y);
    };

    E_Impressions.prototype.getVisual = function() {
      var NormalShapeX, NormalShapeY, NormalShapeZ, i, j, len, output, ref, scale, sillhouettesfunc;
      output = new THREE.Object3D();
      scale = new THREE.Vector3(2, 2, 1);
      sillhouettesfunc = function(self) {
        return function(impression) {
          if (self.isDefined(impression.val_front)) {
            return 1;
          } else {
            return 0;
          }
        };
      };
      if (this.visual_set.has('outline')) {
        this.showValFunc(output, sillhouettesfunc(this));
      }
      NormalShapeX = function(self) {
        return function(impression) {
          var out;
          if (impression.nx === void 0) {
            return null;
          }
          out = Math.floor((impression.nx + 1) * self.partitions);
          return out;
        };
      };
      if (this.visual_set.has('nx')) {
        this.showValFunc(output, NormalShapeX(this));
      }
      NormalShapeY = function(self) {
        return function(impression) {
          if (impression.ny === void 0) {
            return null;
          }
          return Math.floor((impression.ny + 1) * self.partitions);
        };
      };
      if (this.visual_set.has('ny')) {
        this.showValFunc(output, NormalShapeY(this));
      }
      NormalShapeZ = function(self) {
        return function(impression) {
          if (impression.nz === void 0) {
            return null;
          }
          return Math.floor((impression.nz + 1) * self.partitions);
        };
      };
      if (this.visual_set.has('nz')) {
        this.showValFunc(output, NormalShapeZ(this));
      }
      ref = this.impressions;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        if (i.val_front !== null) {
          output.add(this.newPtVisual(i.pos, (i.val_front * this.depth_scale) % 1));
        }
      }
      return output;
    };

    E_Impressions.prototype.showValFunc = function(output, func) {
      var col, down, i, j, k, l, m, pos, ref, ref1, ref2, ref3, right, row, val_down, val_i, val_right;
      for (row = j = 0, ref = this.xNum - 1; 0 <= ref ? j < ref : j > ref; row = 0 <= ref ? ++j : --j) {
        for (col = k = 0, ref1 = this.yNum - 1; 0 <= ref1 ? k < ref1 : k > ref1; col = 0 <= ref1 ? ++k : --k) {
          i = this._getImpression(row, col);
          right = this._getImpression(row, col + 1);
          down = this._getImpression(row + 1, col);
          val_i = func(i);
          val_right = func(right);
          val_down = func(down);
          if (val_i === null) {
            continue;
          }
          if (val_right !== null && val_i !== val_right) {
            pos = i.pos.clone().add(right.pos).divScalar(2);
            i.pt_right = pos;
          }
          if (val_down !== null && val_i !== val_down) {
            pos = i.pos.clone().add(down.pos).divScalar(2);
            i.pt_down = pos;
          }
        }
      }
      for (row = l = 0, ref2 = this.xNum - 1; 0 <= ref2 ? l < ref2 : l > ref2; row = 0 <= ref2 ? ++l : --l) {
        for (col = m = 0, ref3 = this.yNum - 1; 0 <= ref3 ? m < ref3 : m > ref3; col = 0 <= ref3 ? ++m : --m) {
          i = this._getImpression(row, col);
          if (!i.marked && i.hasPt()) {
            output.add(this.traceLine(row, col));
          }
        }
      }
    };

    E_Impressions.prototype.isDefined = function(val) {
      return val !== null;
    };

    E_Impressions.prototype.traceLine = function(row, col) {
      var c, i, j, k, min_dist, new_dist, pline, r, range, ref, ref1, ref2, ref3, right, temp;
      pline = new BDS.Polyline();
      i = this._getImpression(row, col);
      right = true;
      if (i.pt_right) {
        right = true;
      } else {
        right = false;
      }
      while (i.hasPt()) {
        if (i.pt_right && right) {
          pline.addPoint(i.pt_right);
          i.pt_right = null;
        } else if (i.pt_down && !right) {
          pline.addPoint(i.pt_down);
          i.pt_down = null;
        }
        range = 3;
        min_dist = 1000000;
        for (r = j = ref = row - range, ref1 = row + range; ref <= ref1 ? j <= ref1 : j >= ref1; r = ref <= ref1 ? ++j : --j) {
          for (c = k = ref2 = col - range, ref3 = col + range; ref2 <= ref3 ? k <= ref3 : k >= ref3; c = ref2 <= ref3 ? ++k : --k) {
            temp = this._getImpression(r, c);
            if (temp.hasPt()) {
              if (temp.pt_right) {
                new_dist = temp.pt_right.distanceTo(pline.getLastPoint());
                if (new_dist < min_dist) {
                  row = r;
                  col = c;
                  i = temp;
                  right = true;
                  min_dist = new_dist;
                }
              }
              if (temp.pt_down) {
                new_dist = temp.pt_down.distanceTo(pline.getLastPoint());
                if (new_dist < min_dist) {
                  row = r;
                  col = c;
                  i = temp;
                  right = false;
                  min_dist = new_dist;
                }
              }
            }
          }
        }
      }
      return this.newPolylineVisual(pline);
    };

    E_Impressions.prototype.getAllDrawnPoints = function() {
      var i, j, len, mesh, output, pos, ref, scale, val;
      output = new THREE.Object3D();
      ref = this.impressions;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        pos = new THREE.Vector3(i.x, i.y, 0);
        scale = new THREE.Vector3(this.col_w / 2, this.row_h / 2, 1);
        val = i.val;
        if (val === 0) {
          continue;
        }
        mesh = this.unit_meshes.newCircle({
          color: new THREE.Color(val, val, val),
          material: SEE.style.m_flat_fill,
          position: pos,
          scale: scale
        });
        output.add(mesh);
      }
      return output;
    };

    E_Impressions.prototype.clear = function() {
      var i, j, len, ref, results;
      ref = this.impressions;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        results.push(i.clear());
      }
      return results;
    };

    E_Impressions.prototype.newPolylineVisual = function(polyline) {
      var geom, j, len, line_material, pt, pts;
      geom = new THREE.Geometry();
      pts = polyline.toPoints();
      for (j = 0, len = pts.length; j < len; j++) {
        pt = pts[j];
        geom.vertices.push(new THREE.Vector3(pt.x, pt.y, pt.z));
      }
      line_material = SEE.style.m_default_line.clone();
      return new THREE.Line(geom, line_material);
    };

    E_Impressions.prototype.newPtVisual = function(pt, val) {
      var material, mesh, pos, scale;
      scale = new THREE.Vector3(2, 2, 1);
      pos = new THREE.Vector3(pt.x, pt.y, 1);
      material = SEE.style.m_flat_fill.clone();
      mesh = this.unit_meshes.newCircle({
        color: new THREE.Color(val, val, val),
        material: material,
        position: pos,
        scale: scale
      });
      return mesh;
    };

    return E_Impressions;

  })();

}).call(this);
