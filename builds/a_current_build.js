/*! A project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 03-10-2017
 */
// Defined main namespace.
SEE = {};
// Generated by CoffeeScript 1.11.1

/*

Written on Sept.30.2017 by Bryce Summers
Purpose: Generates a set of impressions from models and a camera.

These impression are used to genreate a 3D image.

An Impression Field discretizes and quantizes an image signal into a way of seeing the abstract.
 */

(function() {
  SEE.Impression = (function() {
    function Impression(x1, y1, default_val) {
      this.x = x1;
      this.y = y1;
      this.pos = new BDS.Point(this.x, this.y);
    }

    Impression.prototype.hasPt = function() {
      return this.pt_right !== null || this.pt_down !== null;
    };

    Impression.prototype.clear = function() {
      this.val_front = null;
      this.val_back = null;
      this.pt_right = null;
      this.pt_down = null;
      this.marked = false;
      this.nx = null;
      this.ny = null;
      return this.nz = null;
    };

    return Impression;

  })();

  SEE.E_Impressions = (function() {
    function E_Impressions(xNum, yNum, default_val, width, height) {
      this.visual_set = new Set(['outline', 'nx', 'ny', 'nz']);
      this.partitions = 2;
      this.depth_scale = 5;
      this.unit_meshes = new SEE.Unit_Meshes();
      this.default_val = default_val;
      this.xNum = xNum;
      this.yNum = yNum;
      this.impressions = [];
      this.col_w = width / xNum;
      this.row_h = height / yNum;
      this.width = width;
      this.height = height;
      this._discretize(xNum, yNum, this.col_w, this.row_h, default_val);
    }

    E_Impressions.prototype._discretize = function(xNum, yNum, col_w, row_h, default_val) {
      var col, j, ref, results, row, x, y;
      results = [];
      for (row = j = 0, ref = yNum; j < ref; row = j += 1) {
        results.push((function() {
          var k, ref1, results1;
          results1 = [];
          for (col = k = 0, ref1 = xNum; k < ref1; col = k += 1) {
            x = col_w * col + Math.random() * col_w;
            y = row_h * row + Math.random() * row_h;
            results1.push(this.impressions.push(new SEE.Impression(x, y, 0, default_val)));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    E_Impressions.prototype.getImpression = function(mouse_x, mouse_y) {
      var column, pos, ref, row;
      pos = new BDS.Point(mouse_x, mouse_y);
      ref = this._getRowColumn(pos), row = ref[0], column = ref[1];
      return this._getImpression(row, column);
    };

    E_Impressions.prototype._getImpression = function(row, col) {
      var index;
      index = this._getIndex(row, col);
      return this.impressions[index];
    };

    E_Impressions.prototype._getIndex = function(row, col) {
      if (row >= this.yNum) {
        row = this.yNum - 1;
      }
      if (col >= this.xNum) {
        col = this.xNum - 1;
      }
      if (row < 0) {
        row = 0;
      }
      if (col < 0) {
        col = 0;
      }
      return row * this.xNum + col;
    };

    E_Impressions.prototype._getRowColumn = function(pos) {
      var col, row, x, y;
      x = pos.x;
      y = pos.y;
      row = Math.floor(y / this.row_h);
      col = Math.floor(x / this.col_w);
      return [row, col];
    };

    E_Impressions.prototype.quantize = function(geometry, transform, camera) {
      var i, i1, i2, i3, index, j, k, l, len, m, neighbors, out_indices, ref, ref1, ref2, results, triangle, triangle_list, vertex_normal, vertex_normals;
      out_indices = [];
      geometry = new THREE.Geometry().fromBufferGeometry(geometry);
      geometry.mergeVertices();
      triangle_list = SEE.Math.GeometryToTriangles(geometry, transform, out_indices);
      for (index = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        triangle_list[index] = BDS.Triangle.from_abc_triangle(triangle_list[index]);
      }
      neighbors = {};
      for (index = k = 0, ref1 = triangle_list.length; k < ref1; index = k += 1) {
        triangle = triangle_list[index];
        i1 = out_indices[index * 3];
        i2 = out_indices[index * 3 + 1];
        i3 = out_indices[index * 3 + 2];
        triangle.setIndices(i1, i2, i3);
        this.addNeighbor(neighbors, i1, triangle);
        this.addNeighbor(neighbors, i2, triangle);
        this.addNeighbor(neighbors, i3, triangle);
      }
      vertex_normals = [];
      for (i = l = 0, ref2 = geometry.vertices.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        vertex_normal = this.computeVertexNormal(i, neighbors);
        vertex_normals.push(vertex_normal);
      }
      results = [];
      for (m = 0, len = triangle_list.length; m < len; m++) {
        triangle = triangle_list[m];
        results.push(this._quantizeTriangle(triangle, camera, vertex_normals));
      }
      return results;
    };

    E_Impressions.prototype.computeVertexNormal = function(index, neighbors) {
      var a, average, count, iter, normal, original_index, triangle, triangles, v;
      original_index = index;
      triangles = neighbors[index];
      count = 0;
      average = new THREE.Vector3(0, 0, 0);
      iter = triangles.values();
      while ((v = iter.next(), !v.done)) {
        triangle = v.value;
        normal = triangle.normal();
        a = triangle.a;
        if (a.dot(normal) < 0) {
          normal.multScalar(-1);
        }
        average.add(normal);
        count += 1;
      }
      average.divideScalar(count);
      average.normalize();
      return average;
    };

    E_Impressions.prototype.addNeighbor = function(neighbors, key, val) {
      var list;
      list = neighbors[key];
      if (list === void 0) {
        list = new Set();
        neighbors[key] = list;
      }
      return list.add(val);
    };

    E_Impressions.prototype._quantizeTriangle = function(triangle, camera, vertex_normals) {
      var a_h, a_w, b_h, b_w, bbox, c_h, c_w, i1, i2, i3, imp, imp_set, j, len, n_h, n_w, na_h, na_w, nb_h, nb_w, nc_h, nc_w, normal, per1, per2, per3, ref, screen_a, screen_b, screen_c, screen_polygon, toCamera, toProjection, v, val, z_interp;
      toCamera = camera.matrixWorldInverse;
      toProjection = camera.projectionMatrix;
      v = triangle.a;
      a_w = v;
      a_h = new THREE.Vector4(v.x, v.y, v.z, 1);
      v = triangle.b;
      b_w = v;
      b_h = new THREE.Vector4(v.x, v.y, v.z, 1);
      v = triangle.c;
      c_w = v;
      c_h = new THREE.Vector4(v.x, v.y, v.z, 1);
      v = triangle.normal();
      n_w = v;
      n_h = new THREE.Vector4(v.x, v.y, v.z, 0);
      i1 = triangle.a_index;
      i2 = triangle.b_index;
      i3 = triangle.c_index;
      v = vertex_normals[i1];
      na_w = v;
      na_h = new THREE.Vector4(v.x, v.y, v.z, 0);
      v = vertex_normals[i2];
      nb_w = v;
      nb_h = new THREE.Vector4(v.x, v.y, v.z, 0);
      v = vertex_normals[i3];
      nc_w = v;
      nc_h = new THREE.Vector4(v.x, v.y, v.z, 0);
      a_h.applyMatrix4(toCamera);
      a_h.applyMatrix4(toProjection);
      b_h.applyMatrix4(toCamera);
      b_h.applyMatrix4(toProjection);
      c_h.applyMatrix4(toCamera);
      c_h.applyMatrix4(toProjection);
      n_h.applyMatrix4(toCamera);
      n_h.applyMatrix4(toProjection);
      na_h.applyMatrix4(toCamera);
      na_h.applyMatrix4(toProjection);
      nb_h.applyMatrix4(toCamera);
      nb_h.applyMatrix4(toProjection);
      nc_h.applyMatrix4(toCamera);
      nc_h.applyMatrix4(toProjection);
      screen_a = this.projection_to_screen(a_h);
      screen_b = this.projection_to_screen(b_h);
      screen_c = this.projection_to_screen(c_h);
      bbox = new BDS.Box();
      bbox.expandByPoint(screen_a);
      bbox.expandByPoint(screen_b);
      bbox.expandByPoint(screen_c);
      imp_set = this.lookupImpressionsInBox(bbox);
      screen_polygon = new BDS.Polyline(true, [screen_a, screen_b, screen_c], true);
      a_h.divideScalar(a_h.w);
      b_h.divideScalar(b_h.w);
      c_h.divideScalar(c_h.w);
      for (j = 0, len = imp_set.length; j < len; j++) {
        imp = imp_set[j];
        if (n_h.z < 0 && screen_polygon.containsPoint(imp.pos)) {
          ref = this.baryPercentages(screen_a, screen_b, screen_c, imp.pos), per1 = ref[0], per2 = ref[1], per3 = ref[2];
          val = z_interp = a_h.z * per1 + b_h.z * per2 + c_h.z * per3;
          if (n_h.z < 0) {
            imp.val_front = val;
          } else {
            imp.val_back = val;
          }
          normal = na_h.clone().multiplyScalar(per1).add(nb_h.multiplyScalar(per2)).add(nc_h.multiplyScalar(per3));
          normal.normalize();
          imp.nx = normal.x;
          imp.ny = normal.y;
          imp.nz = normal.z;
        }
      }
    };

    E_Impressions.prototype.baryPercentages = function(screen_a, screen_b, screen_c, pt) {
      var len1, len2, len3, per1, per2, per3, total_len;
      len1 = screen_a.distanceTo(pt);
      len2 = screen_b.distanceTo(pt);
      len3 = screen_c.distanceTo(pt);
      total_len = len1 + len2 + len3;
      per1 = len1 / total_len;
      per2 = len2 / total_len;
      per3 = len3 / total_len;
      return [per1, per2, per3];
    };

    E_Impressions.prototype.lookupImpressionsInBox = function(box) {
      var col, impression, j, k, max, max_column, max_row, min, min_column, min_row, outputs, ref, ref1, ref2, ref3, ref4, ref5, row;
      outputs = [];
      min = box.min;
      max = box.max;
      ref = this._getRowColumn(min), min_row = ref[0], min_column = ref[1];
      ref1 = this._getRowColumn(max), max_row = ref1[0], max_column = ref1[1];
      for (row = j = ref2 = min_row, ref3 = max_row; j <= ref3; row = j += 1) {
        for (col = k = ref4 = min_column, ref5 = max_column; k <= ref5; col = k += 1) {
          impression = this._getImpression(row, col);
          outputs.push(impression);
        }
      }
      return outputs;
    };

    E_Impressions.prototype.projection_to_screen = function(v) {
      var x, y;
      x = (v.x + 1) * this.width / 2;
      y = (v.y + 1) * this.height / 2;
      return new BDS.Point(x, y);
    };

    E_Impressions.prototype.getVisual = function() {
      var NormalShapeX, NormalShapeY, NormalShapeZ, i, j, len, output, ref, scale, sillhouettesfunc;
      output = new THREE.Object3D();
      scale = new THREE.Vector3(2, 2, 1);
      sillhouettesfunc = function(self) {
        return function(impression) {
          if (self.isDefined(impression.val_front)) {
            return 1;
          } else {
            return 0;
          }
        };
      };
      if (this.visual_set.has('outline')) {
        this.showValFunc(output, sillhouettesfunc(this));
      }
      NormalShapeX = function(self) {
        return function(impression) {
          var out;
          if (impression.nx === void 0) {
            return null;
          }
          out = Math.floor((impression.nx + 1) * self.partitions);
          return out;
        };
      };
      if (this.visual_set.has('nx')) {
        this.showValFunc(output, NormalShapeX(this));
      }
      NormalShapeY = function(self) {
        return function(impression) {
          if (impression.ny === void 0) {
            return null;
          }
          return Math.floor((impression.ny + 1) * self.partitions);
        };
      };
      if (this.visual_set.has('ny')) {
        this.showValFunc(output, NormalShapeY(this));
      }
      NormalShapeZ = function(self) {
        return function(impression) {
          if (impression.nz === void 0) {
            return null;
          }
          return Math.floor((impression.nz + 1) * self.partitions);
        };
      };
      if (this.visual_set.has('nz')) {
        this.showValFunc(output, NormalShapeZ(this));
      }
      ref = this.impressions;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        if (i.val_front !== null) {
          output.add(this.newPtVisual(i.pos, (i.val_front * this.depth_scale) % 1));
        }
      }
      return output;
    };

    E_Impressions.prototype.showValFunc = function(output, func) {
      var col, down, i, j, k, l, m, pos, ref, ref1, ref2, ref3, right, row, val_down, val_i, val_right;
      for (row = j = 0, ref = this.xNum - 1; 0 <= ref ? j < ref : j > ref; row = 0 <= ref ? ++j : --j) {
        for (col = k = 0, ref1 = this.yNum - 1; 0 <= ref1 ? k < ref1 : k > ref1; col = 0 <= ref1 ? ++k : --k) {
          i = this._getImpression(row, col);
          right = this._getImpression(row, col + 1);
          down = this._getImpression(row + 1, col);
          val_i = func(i);
          val_right = func(right);
          val_down = func(down);
          if (val_i === null) {
            continue;
          }
          if (val_right !== null && val_i !== val_right) {
            pos = i.pos.clone().add(right.pos).divScalar(2);
            i.pt_right = pos;
          }
          if (val_down !== null && val_i !== val_down) {
            pos = i.pos.clone().add(down.pos).divScalar(2);
            i.pt_down = pos;
          }
        }
      }
      for (row = l = 0, ref2 = this.xNum - 1; 0 <= ref2 ? l < ref2 : l > ref2; row = 0 <= ref2 ? ++l : --l) {
        for (col = m = 0, ref3 = this.yNum - 1; 0 <= ref3 ? m < ref3 : m > ref3; col = 0 <= ref3 ? ++m : --m) {
          i = this._getImpression(row, col);
          if (!i.marked && i.hasPt()) {
            output.add(this.traceLine(row, col));
          }
        }
      }
    };

    E_Impressions.prototype.isDefined = function(val) {
      return val !== null;
    };

    E_Impressions.prototype.traceLine = function(row, col) {
      var c, i, j, k, min_dist, new_dist, pline, r, range, ref, ref1, ref2, ref3, right, temp;
      pline = new BDS.Polyline();
      i = this._getImpression(row, col);
      right = true;
      if (i.pt_right) {
        right = true;
      } else {
        right = false;
      }
      while (i.hasPt()) {
        if (i.pt_right && right) {
          pline.addPoint(i.pt_right);
          i.pt_right = null;
        } else if (i.pt_down && !right) {
          pline.addPoint(i.pt_down);
          i.pt_down = null;
        }
        range = 3;
        min_dist = 1000000;
        for (r = j = ref = row - range, ref1 = row + range; ref <= ref1 ? j <= ref1 : j >= ref1; r = ref <= ref1 ? ++j : --j) {
          for (c = k = ref2 = col - range, ref3 = col + range; ref2 <= ref3 ? k <= ref3 : k >= ref3; c = ref2 <= ref3 ? ++k : --k) {
            temp = this._getImpression(r, c);
            if (temp.hasPt()) {
              if (temp.pt_right) {
                new_dist = temp.pt_right.distanceTo(pline.getLastPoint());
                if (new_dist < min_dist) {
                  row = r;
                  col = c;
                  i = temp;
                  right = true;
                  min_dist = new_dist;
                }
              }
              if (temp.pt_down) {
                new_dist = temp.pt_down.distanceTo(pline.getLastPoint());
                if (new_dist < min_dist) {
                  row = r;
                  col = c;
                  i = temp;
                  right = false;
                  min_dist = new_dist;
                }
              }
            }
          }
        }
      }
      return this.newPolylineVisual(pline);
    };

    E_Impressions.prototype.getAllDrawnPoints = function() {
      var i, j, len, mesh, output, pos, ref, scale, val;
      output = new THREE.Object3D();
      ref = this.impressions;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        pos = new THREE.Vector3(i.x, i.y, 0);
        scale = new THREE.Vector3(this.col_w / 2, this.row_h / 2, 1);
        val = i.val;
        if (val === 0) {
          continue;
        }
        mesh = this.unit_meshes.newCircle({
          color: new THREE.Color(val, val, val),
          material: SEE.style.m_flat_fill,
          position: pos,
          scale: scale
        });
        output.add(mesh);
      }
      return output;
    };

    E_Impressions.prototype.clear = function() {
      var i, j, len, ref, results;
      ref = this.impressions;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        results.push(i.clear());
      }
      return results;
    };

    E_Impressions.prototype.newPolylineVisual = function(polyline) {
      var geom, j, len, line_material, pt, pts;
      geom = new THREE.Geometry();
      pts = polyline.toPoints();
      for (j = 0, len = pts.length; j < len; j++) {
        pt = pts[j];
        geom.vertices.push(new THREE.Vector3(pt.x, pt.y, pt.z));
      }
      line_material = SEE.style.m_default_line.clone();
      return new THREE.Line(geom, line_material);
    };

    E_Impressions.prototype.newPtVisual = function(pt, val) {
      var material, mesh, pos, scale;
      scale = new THREE.Vector3(2, 2, 1);
      pos = new THREE.Vector3(pt.x, pt.y, 1);
      material = SEE.style.m_flat_fill.clone();
      mesh = this.unit_meshes.newCircle({
        color: new THREE.Color(val, val, val),
        material: material,
        position: pos,
        scale: scale
      });
      return mesh;
    };

    return E_Impressions;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Written on Sept.30.2017 by Bryce Summers
Purpose: Initializes and glues everything together.
 */

(function() {
  SEE.E_Scene = (function() {
    function E_Scene() {
      this.scene = new THREE.Scene();
      this.input_root = null;
      this._objects = [];
      this.init_scene();
      this.init_geometries();
      this.seeing_mode = false;
      this.image = new SEE.E_Impressions(200, 200, 0, window.innerWidth, window.innerHeight);
    }

    E_Scene.prototype.init_scene = function() {
      this.init_label("Algo Pipe");
      return this.init_lighting();
    };

    E_Scene.prototype.init_geometries = function() {
      var intergrateIntoScene, loader;
      loader = new THREE.OBJLoader2();
      intergrateIntoScene = function(self, size, position) {
        return function(object) {
          var bbox, geometry, max, max_range, mesh, min, rangex, rangey, rangez, scale, scaleToNormal, translate;
          mesh = object.children[0];
          geometry = mesh.geometry;
          geometry.computeBoundingBox();
          bbox = geometry.boundingBox;
          min = bbox.min;
          max = bbox.max;
          translate = min.clone().multiplyScalar(-1);
          mesh.position.copy(translate);
          rangex = max.x - min.x;
          rangey = max.y - min.y;
          rangez = max.z - min.z;
          max_range = Math.max(rangex, Math.max(rangey, rangez));
          scaleToNormal = 1.0 / max_range;
          scale = scaleToNormal * size;
          mesh.scale.copy(new THREE.Vector3(scale, scale, scale));
          mesh.rotation.copy(new THREE.Euler(0, 1, 0, 'XYZ'));
          mesh.position.copy(position);
          mesh.material = SEE.params.preview_material;
          self.scene.add(object);
          self._objects.push(object);
        };
      };
      return loader.load('data/torus.obj', intergrateIntoScene(this, 200, new THREE.Vector3(70, -40, 0)));
    };

    E_Scene.prototype.getObjects = function() {
      return this._objects;
    };


    /*
    
    External API.
     */

    E_Scene.prototype.setInputRoot = function(input) {
      var input_root;
      return input_root = input;
    };

    E_Scene.prototype.getObjects = function() {
      return this._objects;
    };

    E_Scene.prototype.getVisual = function() {
      if (this.seeing_mode) {
        return this.seeing_scene;
      } else {
        return this.scene;
      }
    };

    E_Scene.prototype.new_ground_plane = function() {
      var divisions, gridHelper, size;
      size = 200;
      divisions = 10;
      gridHelper = new THREE.GridHelper(size, divisions);
      return gridHelper;
    };

    E_Scene.prototype.init_ground_plane = function() {
      var ground_plane;
      ground_plane = this.new_ground_plane();
      this.scene.add(ground_plane);
    };

    E_Scene.prototype.new_label = function(str) {
      var obj, params;
      obj = new THREE.Object3D();
      params = {
        font: SEE.style.fontLoader,
        message: str,
        height: 20,
        out: obj,
        fill_color: 0x000000,
        outline_color: 0x111111
      };
      SEE.style.newText(params);
      obj.position.copy(new THREE.Vector3(-50, 20, -100));
      obj.scale.copy(new THREE.Vector3(1, -1, 1));
      obj.rotation.copy(new THREE.Vector3(0, 0, Math.PI / 2));
      return obj;
    };

    E_Scene.prototype.init_label = function(str) {
      var label;
      label = this.new_label(str);
      this.scene.add(label);
    };

    E_Scene.prototype.init_lighting = function() {
      var ambient, directionalLight;
      ambient = new THREE.AmbientLight(0x404040);
      this.scene.add(ambient);
      directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(0, 1, 1);
      return this.scene.add(directionalLight);
    };

    E_Scene.prototype.enable_normal_mode = function() {
      return this.seeing_mode = false;
    };

    E_Scene.prototype.enable_seeing_mode = function() {
      return this.seeing_mode = true;
    };

    E_Scene.prototype.generate_impressions = function(camera) {
      var geometry, geometryToWorldTransform, group, i, len, mesh, ref;
      this.image.clear();
      ref = this._objects;
      for (i = 0, len = ref.length; i < len; i++) {
        group = ref[i];
        mesh = group.children[0];
        geometry = mesh.geometry;
        mesh.updateMatrixWorld(true);
        geometryToWorldTransform = mesh.matrixWorld.clone();
        this.image.quantize(geometry, geometryToWorldTransform, camera);
      }
      this.seeing_scene = new THREE.Scene();
      return this.seeing_scene.add(this.image.getVisual());
    };

    return E_Scene;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SEE.I_All_Main = (function(superClass) {
    extend(I_All_Main, superClass);

    function I_All_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_All_Main.__super__.constructor.call(this);
      this._mouse_input = new SEE.I_Mouse_Main(this.scene, this.camera);
      this.add_mouse_input_controller(this._mouse_input);
      this.add_time_input_controller(this._mouse_input);
      this._keyboard_input = new SEE.I_Keyboard_Main(this.scene, this.camera);
      this.add_keyboard_input_controller(this._keyboard_input);
      this._time_input = new SEE.I_Time_Main(this.scene, this.camera);
      this.add_time_input_controller(this._time_input);
    }

    I_All_Main.prototype.getMouseController = function() {
      return this._mouse_input;
    };

    return I_All_Main;

  })(BDS.Controller_Group);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SEE.I_Keyboard_Main = (function(superClass) {
    extend(I_Keyboard_Main, superClass);

    function I_Keyboard_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Keyboard_Main.__super__.constructor.call(this);
      this.state = "idle";
      this.add_universal_controller(new SEE.I_Seeing_Mode(this.scene, this.camera));
    }

    return I_Keyboard_Main;

  })(BDS.Controller_Group);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SEE.I_Mouse_Main = (function(superClass) {
    extend(I_Mouse_Main, superClass);

    function I_Mouse_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Mouse_Main.__super__.constructor.call(this);
      this.state = "idle";
      this.add_universal_controller(new SEE.I_Camera_Rotation(this.scene, this.camera));
    }

    return I_Mouse_Main;

  })(BDS.Controller_Group);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Time Input Controller.

Written by Bryce Summmers on 1 - 31 - 2017.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SEE.I_Time_Main = (function(superClass) {
    extend(I_Time_Main, superClass);

    function I_Time_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Time_Main.__super__.constructor.call(this);
    }

    return I_Time_Main;

  })(BDS.Controller_Group);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  SEE.I_Tool_Controller = (function() {
    function I_Tool_Controller(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      this.active = true;
    }

    I_Tool_Controller.prototype.setActive = function(val) {
      return this.active = val;
    };

    I_Tool_Controller.prototype.isActive = function() {
      return this.active;
    };

    return I_Tool_Controller;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Super class to mesh construction classes.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
        Deals with all of the common problems such as adding a material and changing its color.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SEE.Mesh_Basic = (function(superClass) {
    extend(Mesh_Basic, superClass);

    function Mesh_Basic(area_geometry, outline_geometry) {
      this.outline_geometry = outline_geometry;
      this.fill_material = SEE.style.m_default_fill.clone();
      Mesh_Basic.__super__.constructor.call(this, area_geometry, this.fill_material);
      this.line_material = SEE.style.m_default_line.clone();
    }

    Mesh_Basic.prototype.clone = function(params) {
      var mesh, outline, output;
      output = new THREE.Object3D();
      mesh = new SEE.Mesh_Basic(this.geometry);
      outline = new THREE.Line(this.outline_geometry, this.line_material);
      outline.renderOrder = 1;
      output.add(mesh);
      output.add(outline);
      if (params.material) {
        mesh.material = params.material;
      }
      if (params.color) {
        if (!(params.color instanceof THREE.Color)) {
          debugger;
        }
        mesh.material.color = params.color;
      }
      if (params.position) {
        output.position.copy(params.position);
      }
      if (params.scale) {
        output.scale.copy(params.scale);
      }
      if (params.rotation) {
        output.rotation.copy(params.rotation);
      }
      output.setFillColor = function(c) {
        return this.children[0].material.color = c;
      };
      output.revertFillColor = function() {
        return this.children[0].material.color = SEE.style.m_default_fill.color.clone();
      };
      return output;
    };

    return Mesh_Basic;

  })(THREE.Mesh);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  SEE.Unit_Meshes = (function() {
    function Unit_Meshes() {
      this._square = new SEE.Mesh_Unit_Square();
      this._circle = new SEE.Mesh_Unit_Circle();
      this._triangle = new SEE.Mesh_Unit_Triangle();
    }

    Unit_Meshes.prototype.newSquare = function(params) {
      return this._square.clone(params);
    };

    Unit_Meshes.prototype.newCircle = function(params) {
      return this._circle.clone(params);
    };

    Unit_Meshes.prototype.newTriangle = function(params) {
      return this._triangle.clone(params);
    };

    return Unit_Meshes;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  SEE.S_Curve = (function() {
    function S_Curve() {
      this._spline = new BDS.Polyline(false);
      this._point_discretization = [];
      this._cumulative_lengths = [];
      this._unit_tangents = [];
      this._total_length = 0;
    }

    S_Curve.prototype.addPoint = function(p) {
      this._spline.addPoint(this.vec_to_point(p));
      this._total_length += this._spline.getLastSegmentDistance();
      this._cumulative_lengths.push(this._total_length);
      if (this.numPoints() > 1) {
        this._unit_tangents.push(this._spline.getLastSegmentDirection());
      }
    };

    S_Curve.prototype.numPoints = function() {
      return this._spline.size();
    };

    S_Curve.prototype.getPointAtIndex = function(i) {
      return this.point_to_vec(this._spline.getPoint(i));
    };

    S_Curve.prototype.getLastPoint = function() {
      return this.point_to_vec(this._spline.getLastPoint());
    };

    S_Curve.prototype.removeLastPoint = function() {
      this._total_length -= this._spline.getLastSegmentDistance();
      this._cumulative_lengths.pop();
      this._unit_tangents.pop();
      return this._spline.removeLastPoint();
    };

    S_Curve.prototype.position = function(t) {
      var dir, distance, distance_to_go, i1, i2, p1, p2, start_distance;
      i1 = this._get_segment_start_index(t);
      if (i1 >= this.numPoints() - 1) {
        return this.getLastPoint();
      }
      i2 = i1 + 1;
      distance = t * this._total_length;
      start_distance = this._cumulative_lengths[i1];
      distance_to_go = distance - start_distance;
      p1 = this._spline.getPoint(i1);
      p2 = this._spline.getPoint(i2);
      dir = p1.directionTo(p2);
      return this.point_to_vec(p1.add(dir.multScalar(distance_to_go)));
    };

    S_Curve.prototype.tangent = function(t) {
      var index;
      index = this._get_segment_start_index(t);
      if (index >= this._unit_tangents.length) {
        index--;
      }
      return this.point_to_vec(this._unit_tangents[index]);
    };

    S_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    S_Curve.prototype._get_segment_start_index = function(t) {
      var distance;
      distance = t * this._total_length;
      return BDS.Arrays.binarySearch(this._cumulative_lengths, distance);
    };

    S_Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    S_Curve.prototype.updateDiscretization = function(max_length) {
      var index, j, len, ref, vec;
      this._discretization = [];
      len = this.numPoints();
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        vec = this.getPointAtIndex(index);
        this._discretization.push(vec);
      }
      return this._discretization;
    };

    S_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var distance, j, len, len1, out, ref, time;
      out = [];
      len = 0;
      ref = this._cumulative_lengths;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        distance = ref[j];
        time = distance / this._total_length;
        times_output.push(time);
        out.push(this.offset(time, amount));
      }
      return out;
    };


    /*
    updateDiscretization: (max_length) ->
        output = []
        p0 = @position(0)
        output.push(p0)
    
        S = [] # Stack.
        S.push(1.0)
        
        low   = 0
        p_low = @position(low)
    
         * The stack stores the right next upper interval.
         * The lower interval starts at 0 and is set to the upper interval
         * every time an interval is less than the max_length, subdivision is terminated.
    
         * Left to right subdivision loop. Performs a binary search across all intervals.
        while S.length != 0
        
            high   = S.pop()
            p_high = @position(high)
        
             * Subdivision is sufficient, move on to the next point.
            while p_low.distanceTo(p_high) > max_length
                 * Otherwise subdivide the interval and keep going.
                S.push(high)
                high   = (low + high)/2.0
                p_high = @position(high)
        
            output.push(p_high)
            low   = high
            p_low = p_high
            continue
    
        @_discretization = output
    
     * max_length:float, maximum length out output segment.
     * amount: the distance the offset curve is away from the main curve. positive or negative is fine.
     * time_output (optional) will be populated with the times for the output points.
     * ASSUMPTION: this function assumes that it is sampling from continuously defined offsets.
    getOffsets: (max_length, amount, times_output) ->
    
        o0 = @offset(0, amount)
        output = []
        output.push(o0)
        times_output.push(0) if times_output
    
        S = []; # Stack.
        S.push(1.0)
        low = 0
        p_low = @offset(low, amount)
    
         * The stack stores the right next upper interval.
         * The lower interval starts at 0 and is set to the upper interval.
         * every time an interval is terminated after subdivision is sufficient.
    
         * Left to right subdivision loop.
        while S.length != 0
        
            high   = S.pop()
            p_high = @offset(high, amount)
    
             * Subdivision is sufficient, move on to the next point.
            while p_low.distanceTo(p_high) > max_length
            
                 * Otherwise subdivide the interval and keep going.
                S.push(high)
                high = (low + high)/2.0
                p_high = @offset(high, amount)
            
    
            output.push(p_high)
            times_output.push(high) if times_output
            low = high
            p_low = p_high
            continue
        
        return output
     */

    S_Curve.prototype.threeVectorsToBDSPolyline = function(vecs) {
      var j, len1, polyline, vec;
      polyline = new BDS.Polyline(false);
      for (j = 0, len1 = vecs.length; j < len1; j++) {
        vec = vecs[j];
        polyline.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return polyline;
    };

    S_Curve.prototype.vec_to_point = function(vec) {
      return new BDS.Point(vec.x, vec.y);
    };

    S_Curve.prototype.point_to_vec = function(pt) {
      return new THREE.Vector3(pt.x, pt.y);
    };

    S_Curve.prototype.length = function() {
      return this._total_length;
    };

    return S_Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Global Style objects, including materials for roads, lines, etc.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 */

(function() {
  SEE.init_style = function() {
    SEE.style = {
      renderer_clear_color: 0x000000,
      discretization_length: 10,
      pipe_radius: 10,
      m_default_fill: new THREE.MeshLambertMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide
      }),
      m_flat_fill: new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide
      }),
      m_default_line: new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 5
      }),
      m_transparent: new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: .1
      }),
      m_translucent: new THREE.MeshLambertMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: .5
      }),
      highlight: new THREE.Color(0x0000ff),
      error: new THREE.Color(0xff0000),
      action: new THREE.Color(0x72E261),
      c_normal: new THREE.Color(0xdddddd)
    };
    SEE.params = {
      preview_material: SEE.style.m_default_fill
    };
    SEE.style.loader = new THREE.TextureLoader();
    SEE.style.newSprite = function(url, dim) {
      var container, geom, mat, mesh, texture;
      texture = SEE.style.loader.load(url);
      geom = new THREE.PlaneBufferGeometry(dim.w, dim.h, 32);
      mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
        map: texture,
        transparent: true
      });
      mesh = new THREE.Mesh(geom, mat);
      mesh.position.x = dim.w / 2;
      mesh.position.y = dim.h / 2;
      mesh.rotation.z = Math.PI;
      mesh.scale.x = -1;
      container = new THREE.Object3D();
      container.add(mesh);
      container.position.x = dim.x;
      container.position.y = dim.y;
      return container;
    };
    SEE.style.fontLoader = new THREE.FontLoader();
    SEE.style.textMeshQueue = [];

    /*
    SEE.style.fontLoader.load('fonts/Raleway_Regular.typeface.json',
                               (font) ->
    
                                    SEE.style.font = font
    
                                    for params in SEE.style.textMeshQueue
                                        SEE.style.newText(params)
                               )
     */
    SEE.style.newText = function(params) {
      var geometry, message, shapes;
      if (!SEE.style.font) {
        SEE.style.textMeshQueue.push(params);
        return;
      }
      if (params.fill_color || params.outline_color) {
        message = params.message;
        shapes = SEE.style.font.generateShapes(message, params.height, 2);
        geometry = new THREE.ShapeGeometry(shapes);
        geometry.computeBoundingBox();
      }
      if (params.fill_color) {
        SEE.style.newFillText(params, shapes, geometry);
      }
      if (params.outline_color) {
        return SEE.style.newOutlineText(params, shapes, geometry);
      }
    };
    SEE.style.newFillText = function(params, shapes, geometry) {
      var color_fill, material_fill, output, text, textShape, tx, xMid;
      output = params.out;
      textShape = new THREE.BufferGeometry();
      color_fill = params.fill_color;
      material_fill = new THREE.LineBasicMaterial({
        color: color_fill,
        side: THREE.DoubleSide
      });
      xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      geometry.scale(1, -1, 1);
      tx = 0;
      if (params.align_center) {
        tx = xMid;
      }
      geometry.translate(tx, params.height, 0);
      textShape.fromGeometry(geometry);
      text = new THREE.Mesh(textShape, material_fill);
      return output.add(text);
    };
    return SEE.style.newOutlineText = function(params, shapes, geometry) {
      var color_outline, hole, holeShapes, i, j, k, l, lineGeometry, lineMesh, lineText, m, material_outline, output, ref, ref1, ref2, shape, tx;
      output = params.out;
      color_outline = params.outline_color;
      material_outline = new THREE.MeshBasicMaterial({
        color: color_outline,

        /*
        transparent: true,
        opacity: 1.0,
        FIXME: Specify Opacity settings.
         */
        side: THREE.DoubleSide
      });
      holeShapes = [];
      for (i = k = 0, ref = shapes.length; k < ref; i = k += 1) {
        shape = shapes[i];
        if (shape.holes && shape.holes.length > 0) {
          for (j = l = 0, ref1 = shape.holes.length; l < ref1; j = l += 1) {
            hole = shape.holes[j];
            holeShapes.push(hole);
          }
        }
      }
      shapes.push.apply(shapes, holeShapes);
      lineText = new THREE.Object3D();
      tx = 0;
      if (params.align_center) {
        tx = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      }
      for (i = m = 0, ref2 = shapes.length; m < ref2; i = m += 1) {
        shape = shapes[i];
        lineGeometry = shape.createPointsGeometry();
        lineGeometry.scale(1, -1, 1);
        lineGeometry.translate(tx, params.height, 0);
        lineMesh = new THREE.Line(lineGeometry, material_outline);
        lineText.add(lineMesh);
      }
      output.add(lineText);
    };
  };

  SEE.init_style();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  SEE.Profiler = (function() {
    function Profiler(name) {
      this.name_string = name;
      this.overall_time = 0;
      this.num_logs = 0;
      this.min_time = Number.MAX_VALUE;
      this.max_time = Number.MIN_VALUE;
    }

    Profiler.prototype.logTime = function(time) {
      this.num_logs += 1;
      this.overall_time += time;
      this.min_time = Math.min(this.min_time, time);
      return this.max_time = Math.max(this.max_time, time);
    };

    Profiler.prototype.toString = function() {
      return this.name_string + "time log: (average: " + this.overall_time / this.num_logs + ", min: " + this.min_time + ", max: " + this.max_time + ") milliseconds.";
    };

    return Profiler;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Testing Routines.
 *
 * Here, I will unit test any data structures that I write to ensure some numerical sanity.
 */

(function() {
  SEE.Test = function() {
    return new SEE.Testing();
  };

  SEE.Testing = (function() {
    function Testing() {
      this.test_triangle_ray_intersection();
    }

    Testing.prototype.test_triangle_ray_intersection = function() {

      /*
      origin = new BDS.Point(0, 0, 0)
      dir    = new BDS.Point(0, 0, 1)
      
       * Z perpendicular triangle that contains the ray.
      a = new BDS.Point(-5, 5,  5)
      b = new BDS.Point( 5, 5,  5)
      c = new BDS.Point( 0, -5, 5)
      triangle = new BDS.Triangle(a, b, c)
      
      ray      = new BDS.Ray(origin, dir)
      rayQuery = new BDS.RayQuery(ray)
      
      result = triangle.rayQueryTime(rayQuery)
      
      console.log("Should be true, .time = 5")
      console.log(result)
      console.log(rayQuery)
      
      result = triangle.rayQueryTimes(rayQuery)
      console.log(result)
      console.log(rayQuery)
      
      result = triangle.rayQueryMin(rayQuery)
      console.log(result)
      console.log(rayQuery)
      
      result = triangle.rayQueryAll(rayQuery)
      console.log(result)
      console.log(rayQuery)
       */
      var dir, i, j, len, len1, mesh, origin, ray, rayQuery, tri, triangle_list;
      origin = new BDS.Point(.5, -.5, .5);
      dir = new BDS.Point(0, 1, 0);
      ray = new BDS.Ray(origin, dir);
      rayQuery = new BDS.RayQuery(ray);
      triangle_list = BDS.Mesh_Builder.new_cube();
      for (i = 0, len = triangle_list.length; i < len; i++) {
        tri = triangle_list[i];
        tri.rayQueryAll(rayQuery);
      }
      console.log(rayQuery.objs.length >= 4);
      rayQuery.reset();
      for (j = 0, len1 = triangle_list.length; j < len1; j++) {
        tri = triangle_list[j];
        tri.rayQueryMin(rayQuery);
      }
      console.log(rayQuery.min_time <= .51);
      mesh = new BDS.Mesh({
        triangles: triangle_list,
        bvh: true
      });
      rayQuery.reset();
      mesh.rayQueryMin(rayQuery);
      return console.log(rayQuery);
    };


    /*
        #@test_AABB()
    
    
    test_AABB: () ->
    
        scene = new THREE.Scene()
    
        geometry = new THREE.Geometry()
    
        y = 0
        for x in [0 .. 10]
            mesh = @test_mesh(new THREE.Vector3(x*3 +  0, y*3 + 1, 0 ),
                              new THREE.Vector3(x*3 + -1, y*3 - 1, 0 ),
                              new THREE.Vector3(x*3 +  1, y*3 - 1, 0 ))
            scene.add( mesh )
    
        AABB = new TSAG.AABB(scene, {val: 'x', dim:2})
    
        origin    = new THREE.Vector3(0, 0, -10)
        direction = new THREE.Vector3(0, 0, 1)
        ray = new THREE.Ray(origin, direction)
    
        [mesh, inter] = AABB.collision_query(ray)
    
        console.log(mesh)
        console.log(inter)
    
     * Returns a test triangle mesh.
    test_mesh: (a, b, c) ->
    
        geometry = new THREE.Geometry()
        geometry.vertices.push(a, b, c)
    
        geometry.faces.push( new THREE.Face3( 0, 1, 2 ) )
    
        material = new THREE.MeshBasicMaterial( { color: 0xffff00 } )
        mesh = new THREE.Mesh( geometry, material )
     */

    return Testing;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  SEE.Math = {};

  SEE.Math.distance = function(x1, y1, x2, y2, z1, z2) {
    return Math.sqrt(SEE.Math.distance_sqr(x1, y1, x2, y2, z1, z2));
  };

  SEE.Math.distance_sqr = function(x1, y1, x2, y2, z1, z2) {
    var dx, dy, dz;
    if (z1 === void 0) {
      dz = 0;
    } else {
      dz = z1 - z2;
    }
    dx = x1 - x2;
    dy = y1 - y2;
    return dx * dx + dy * dy + dz * dz;
  };

  SEE.Math.GeometryToTriangles = function(geometry, vertexTransform, out_indices) {
    var a, b, c, face, faces, i, index_a, index_b, index_c, j, k, l, len, len1, output, ref, ref1, triangle, v1, v2, v3, vert_a, vert_b, vert_c, verts;
    if (vertexTransform === void 0) {
      vertexTransform = new Matrix3();
    }
    if (geometry instanceof THREE.Geometry) {
      console.log(geometry);
      faces = geometry.faces;
      verts = geometry.vertices;
      output = [];
      for (j = 0, len1 = faces.length; j < len1; j++) {
        face = faces[j];
        index_a = face.a;
        index_b = face.b;
        index_c = face.c;
        vert_a = verts[index_a].clone().applyMatrix4(vertexTransform);
        vert_b = verts[index_b].clone().applyMatrix4(vertexTransform);
        vert_c = verts[index_c].clone().applyMatrix4(vertexTransform);
        triangle = new THREE.Triangle(vert_a, vert_b, vert_c);
        output.push(triangle);
        if (out_indices) {
          out_indices.push(index_a);
          out_indices.push(index_b);
          out_indices.push(index_c);
        }
      }
      return output;
    }
    if (geometry instanceof THREE.BufferGeometry) {
      verts = geometry.getAttribute('position');
      faces = geometry.getAttribute('index');
      if (!faces) {
        len = verts.count;
        faces = [];
        for (i = k = 0, ref = len; k < ref; i = k += 3) {
          faces.push(i);
          faces.push(i + 1);
          faces.push(i + 2);
        }
      } else {
        faces = faces.array;
      }
      output = [];
      len = faces.length;
      for (i = l = 0, ref1 = len; l < ref1; i = l += 3) {
        a = faces[i];
        b = faces[i + 1];
        c = faces[i + 2];
        v1 = new THREE.Vector3(verts.getX(a), verts.getY(a), verts.getZ(a));
        v2 = new THREE.Vector3(verts.getX(b), verts.getY(b), verts.getZ(b));
        v3 = new THREE.Vector3(verts.getX(c), verts.getY(c), verts.getZ(c));
        v1.applyMatrix4(vertexTransform);
        v2.applyMatrix4(vertexTransform);
        v3.applyMatrix4(vertexTransform);
        triangle = new THREE.Triangle(v1, v2, v3);
        output.push(triangle);
        if (out_indices) {
          out_indices.push(a);
          out_indices.push(b);
          out_indices.push(c);
        }
      }
      return output;
    }
    debugger;
    console.error("ERROR: SEE.Math.GeometryToTriangles, Geometry Input Type not supported:" + geometry);
  };

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Camera Rotation Controller

Written by Bryce Summmers on 6 - 6 - 2017.

 - A mouse controller that allows a user to rotate the view in the xz plane
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SEE.I_Camera_Rotation = (function(superClass) {
    extend(I_Camera_Rotation, superClass);

    function I_Camera_Rotation(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Camera_Rotation.__super__.constructor.call(this);
      this._mouse_pressed = false;
      this._mouse_press_x = null;
      this._mouse_press_y = null;
      this._camera_angle = Math.PI / 4;
      this._start_angle = this._camera_angle;
      this._target_angle = this._camera_angle;
      this._camera_height = 300;
      this._start_height = this._camera_height;
      this._target_height = this._camera_height;
      this._zoom = 2;
    }

    I_Camera_Rotation.prototype.mouse_down = function(event) {
      this._mouse_pressed = true;
      this._start_angle = this._camera_angle;
      this._start_height = this._camera_height;
      this._mouse_press_x = event.x;
      return this._mouse_press_y = event.y;
    };

    I_Camera_Rotation.prototype.mouse_up = function(event) {
      return this._mouse_pressed = false;
    };

    I_Camera_Rotation.prototype.mouse_move = function(event) {
      var dx, dy;
      if (!this._mouse_pressed) {
        return;
      }
      dx = event.x - this._mouse_press_x;
      dy = event.y - this._mouse_press_y;
      this._target_angle = this._start_angle + Math.PI * 2 * dx / dim.w;
      return this._target_height = this._start_height + dy;
    };

    I_Camera_Rotation.prototype.mouse_wheel = function(event) {
      this._cameraZoom(-event.deltaY / 1000.0);
    };

    I_Camera_Rotation.prototype.time = function(dt) {
      var dist, per, per_c, x, y, z;
      per = .9;
      per_c = 1.0 - per;
      this._camera_angle = per * this._camera_angle + per_c * this._target_angle;
      this._camera_height = per * this._camera_height + per_c * this._target_height;
      dist = 200;
      x = dist * Math.cos(this._camera_angle);
      y = this._camera_height;
      z = dist * Math.sin(this._camera_angle);
      this.camera.position.copy(new THREE.Vector3(x, y, z));
      return this.camera.lookAt(new THREE.Vector3(0, 0, 0));
    };

    I_Camera_Rotation.prototype._cameraZoom = function(amount) {
      this._zoom += amount;
      this.camera.left = dim.w / -2 / this._zoom;
      this.camera.right = dim.w / 2 / this._zoom;
      this.camera.top = dim.h / 2 / this._zoom;
      this.camera.bottom = dim.h / -2 / this._zoom;
      this.camera.updateProjectionMatrix();
    };

    return I_Camera_Rotation;

  })(BDS.Interface_Controller_All);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Cube Rotation Controller.

Written by Bryce Summmers on 6 - 6 - 2017.

 - A Test time controller that takes every cube in the scene and rotates it by a fixed amount.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SEE.I_Rotate_Cubes = (function(superClass) {
    extend(I_Rotate_Cubes, superClass);

    function I_Rotate_Cubes(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Rotate_Cubes.__super__.constructor.call(this);
      this.time_count = 0.0;
      this.time_step = 2000.0;
    }

    I_Rotate_Cubes.prototype.time = function(dt) {
      var cube, cubes, i, len;
      cubes = this.scene.getObjects();
      for (i = 0, len = cubes.length; i < len; i++) {
        cube = cubes[i];
        cube.rotation.x += dt * .001;
        cube.rotation.y += dt * .001;
      }
    };

    return I_Rotate_Cubes;

  })(BDS.Interface_Controller_Time);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Camera Rotation Controller

Written by Bryce Summmers on 6 - 6 - 2017.

 - A mouse controller that allows a user to rotate the view in the xz plane
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SEE.I_Seeing_Mode = (function(superClass) {
    extend(I_Seeing_Mode, superClass);

    function I_Seeing_Mode(scene, camera) {
      var dim, zoom;
      this.scene = scene;
      this.camera = camera;
      I_Seeing_Mode.__super__.constructor.call(this);
      this._key_down = false;
      this.NORMAL = 0;
      this.SEEING = 1;
      this.mode = this.NORMAL;
      dim = {
        x: 0,
        y: 0,
        w: window.innerWidth,
        h: innerHeight,
        padding: 10
      };
      zoom = 1;
      this.seeing_camera = new THREE.OrthographicCamera(dim.w / -2 / zoom, dim.w / 2 / zoom, dim.h / 2 / zoom, dim.h / -2 / zoom, 1, 600);
      this.normal_camera = this.camera;
      this.seeing_camera.position.copy(new THREE.Vector3(dim.w / 2, dim.h / 2, 2));
      this.seeing_camera.lookAt(new THREE.Vector3(dim.w / 2, dim.h / 2, 0));
    }

    I_Seeing_Mode.prototype.key_down = function(event) {
      return this._key_down = true;
    };

    I_Seeing_Mode.prototype.key_up = function(event) {
      this._key_down = false;
      if (event.key === " ") {
        if (this.mode === this.NORMAL) {
          this.scene.generate_impressions(this.normal_camera);
          this.scene.enable_seeing_mode();
          window.root_camera = this.seeing_camera;
          this.mode = this.SEEING;
        } else if (this.mode === this.SEEING) {
          window.root_camera = this.normal_camera;
          this.mode = this.NORMAL;
          this.scene.enable_normal_mode();
        }
      }
    };

    I_Seeing_Mode.prototype.time = function(dt) {};

    return I_Seeing_Mode;

  })(BDS.Interface_Controller_All);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Circle Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SEE.Mesh_Unit_Circle = (function(superClass) {
    extend(Mesh_Unit_Circle, superClass);

    function Mesh_Unit_Circle() {
      var geometry, outline, radius, segments, theata0, theata1;
      radius = .5;
      segments = 25;
      theata0 = 0;
      theata1 = Math.PI * 2;
      geometry = new THREE.CircleGeometry(radius, 25, theata0, theata1);
      outline = new THREE.Geometry();

      /*
      outline.vertices.push(
          new THREE.Vector3( -.5, -.5, 0 ),
          new THREE.Vector3(  .5, -.5, 0 ),
          new THREE.Vector3(  .5,  .5, 0 ),
          new THREE.Vector3( -.5,  .5, 0 ),
          new THREE.Vector3( -.5, -.5, 0 ) # Closed.
      );
       */
      Mesh_Unit_Circle.__super__.constructor.call(this, geometry, outline);
    }

    return Mesh_Unit_Circle;

  })(SEE.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Square Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SEE.Mesh_Unit_Square = (function(superClass) {
    extend(Mesh_Unit_Square, superClass);

    function Mesh_Unit_Square() {
      var geometry, outline;
      geometry = new THREE.PlaneGeometry(1, 1);
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(-.5, -.5, 0), new THREE.Vector3(.5, -.5, 0), new THREE.Vector3(.5, .5, 0), new THREE.Vector3(-.5, .5, 0), new THREE.Vector3(-.5, -.5, 0));
      Mesh_Unit_Square.__super__.constructor.call(this, geometry, outline);
    }


    /*
    setup_texture_coordinates: () ->
        @geometry.faceVertexUvs.push(uv_coords)
    
        s = 1
    
        v1 = new THREE.Vector2(0, 0)
        v2 = new THREE.Vector2(s, 0)
        v3 = new THREE.Vector2(s, s)
        v4 = new THREE.Vector2(0, s)
    
        uv_coords.push([v1, v2, v3])
        uv_coords.push([v1, v3, v4])
    
        @geometry.uvsNeedUpdate = true
    
        @geometry.computeBoundingSphere()
    
        @geometry.computeFaceNormals()
        @geometry.computeVertexNormals()
        
        @geometry.verticesNeedUpdate = true
                
         * Changes to Vertex normals.
        @geometry.normalsNeedUpdate = true
        @geometry.colorsNeedUpdate = true
     */

    return Mesh_Unit_Square;

  })(SEE.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Triangle Mesh.

    Description:
     - Provides a Triangle Pointing in the positive x (-->) direction
     - Along the x axis it is of length 1.
     - Along the y axis it is of length 1, but centered

    Written by Bryce Summers on 11/22/2016.
    
    Purpose: Used for many things, including the tops of houses.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SEE.Mesh_Unit_Triangle = (function(superClass) {
    extend(Mesh_Unit_Triangle, superClass);

    function Mesh_Unit_Triangle() {
      var interior, outline;
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -.5, 0), new THREE.Vector3(0, +.5, 0), new THREE.Vector3(1, 0, 0));
      interior = outline.clone();
      interior.faces.push(new THREE.Face3(0, 1, 2));
      Mesh_Unit_Triangle.__super__.constructor.call(this, interior, outline);
    }

    return Mesh_Unit_Triangle;

  })(SEE.Mesh_Basic);

}).call(this);
